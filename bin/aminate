#!/usr/bin/env python2.7
#
#
#  Copyright 2013 Netflix, Inc.
#
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
#

import datetime
import sys
import urllib
import boto.utils
from boto.ec2.blockdevicemapping import *
from aminator.utils import ec2connection, register, add_tags, this_instance, pid
from aminator.volumemanager import VolumeManager
from aminator.packagefetcher import PackageFetcher

import logging
from logging.handlers import SysLogHandler
log = logging.getLogger('aminate')

now = datetime.datetime.utcnow

ebs = 'ebs'
s3 = 's3'

rootdev = '/dev/sda1'
sdb = '/dev/sdb'
sdc = '/dev/sdc'
sdd = '/dev/sdd'
sde = '/dev/sde'


def logging_init():

    console = logging.StreamHandler(sys.stdout)
    console.setFormatter(logging.Formatter('%(asctime)s - %(message)s', '%F %T'))
    console.setLevel(logging.INFO)

    syslog = SysLogHandler(address='/dev/log', facility=SysLogHandler.LOG_LOCAL1)
    syslog.setFormatter(logging.Formatter('%(name)s[%(process)d]: %(levelname)s %(message)s'.encode('utf-8')))
    syslog.setLevel(logging.DEBUG)

    log.addHandler(syslog)
    log.addHandler(console)
    log.setLevel(logging.DEBUG)

    logging.getLogger('aminator').addHandler(syslog)
    logging.getLogger('aminator').setLevel(logging.DEBUG)
    log.root.setLevel(logging.DEBUG)


def new_ephemeral_mapping():
    """
    :rtype: `boto.ec2.blockdevicemapping.BlockDeviceMapping`
    :return: a ephemeral block device mapping for image registration
    """
    bdm = BlockDeviceMapping(connection=ec2connection())
    bdm[sdb] = BlockDeviceType(ephemeral_name='ephemeral0')
    bdm[sdc] = BlockDeviceType(ephemeral_name='ephemeral1')
    bdm[sdd] = BlockDeviceType(ephemeral_name='ephemeral2')
    bdm[sde] = BlockDeviceType(ephemeral_name='ephemeral3')
    return bdm


class BakeReqError(StandardError):
    """
    aminator Device error
    """
    def __init__(self, reason):
        StandardError.__init__(self, reason)
        self.reason = reason

    def __repr__(self):
        return 'BakeReqError: %s' % self.reason

    def __str__(self):
        return 'BakeReqError: %s' % self.reason


class BakeRequest(object):
    def __init__(self, pkg=None, base=None, wants_ebs=True, wants_s3=False, name=None, suffix=None,
                       virtualization_type=None, creator=None):
        log.info('looking up package %s' % pkg)
        self.fetcher = PackageFetcher(pkg)
        self.base = base
        self.tags = {}
        self.snapshot_tags = {}
        self.ami = None
        self.wants_ebs = wants_ebs
        self.wants_s3 = wants_s3
        self.name = name
        self.suffix = suffix
        self.vol = None
        self.description = ""
        self.tags['creator'] = creator
        self.snapshot_tags['creator'] = creator

    def bake(self):
        with VolumeManager(self.base) as vol:
            log.info("baking %s with base AMI %s on %s attached to %s and mounted on %s" %
                    (self.fetcher.rpmfile, vol.ami.name, vol.id, vol.dev, vol.mnt))
            self.vol = vol
            self.mnt = vol.mnt
            if self._install() is not True:
                log.error('package installation failed.')
                return False
            log.info('%s installation complete.' % self.fetcher.rpmfile)
            self._set_attrs()
            log.info('creating snapshot')
            vol.add_snap(self.description)
            log.info('%s: snapshot complete' % vol.snapshot.id)
            if self._finish() is not True:
                log.error('bake failed.')
                return False
        if self.vol.deleted:
            log.debug('%s deleted' % self.vol.id)
        else:
            log.debug('%s has not been deleted.' % self.vol.id)
        return True

    def _install(self):
        """ install self.pkg onto the file system rooted in self.mnt
        """
        self.fetcher.fetch("%s/var/cache" % (self.mnt))
        cmd = boto.utils.ShellCommand("/usr/bin/aminator.sh -t %s -a install %s %s" % (pid,
                                                                                       self.fetcher.rpmfilepath,
                                                                                       self.mnt))
        if cmd.getStatus() == 0:
            return True
        else:
            log.debug(cmd.output)
            return False

    def _finish(self):
        # register the snapshot
        # tag the ami and snapshot
        bdm = new_ephemeral_mapping()
        bdm[rootdev] = BlockDeviceType(snapshot_id=self.vol.snapshot.id, delete_on_termination=True)
        ami = boto.ec2.image.Image(ec2connection())
        ami = register(name="%s-%s" % (self.name, ebs),
                       description=self.description,
                       architecture=self.vol.ami_metadata['arch'],
                       block_device_map=bdm,
                       root_device_name=rootdev,
                       kernel_id=self.vol.ami_metadata['aki'],
                       ramdisk_id=self.vol.ami_metadata['ari'])

        if ami is not None:
            log.info('AMI registered: %s %s' % (ami.id, ami.name))
            self.ami = ami
            self.tags['creation_time'] = now().strftime('%F %T UTC')
            self.snapshot_tags['ami-id'] = ami.id

            add_tags([ami.id], self.tags)
            ami.update()
            for k in ami.tags:
                log.info('TAG\timage\t%s\t%s\t%s' % (ami.id, k, ami.tags[k]))

            add_tags([self.vol.snapshot.id], self.snapshot_tags)
            self.vol.snapshot.update()
            for k in self.vol.snapshot.tags:
                log.debug('TAG\tsnapshot\t%s\t%s\t%s' % (self.vol.snapshot.id, k, self.vol.snapshot.tags[k]))

        return self.ami is not None

    def _set_attrs(self):
        self.tags['appversion'] = self.fetcher.appversion
        self.snapshot_tags['appversion'] = self.fetcher.appversion
        self.tags['base_ami_version'] = self.vol.ami_metadata['base_ami_version']
        if self.name is None:
            self.name = "%s-%s-%s" % (self.fetcher.name_ver_rel, self.vol.ami_metadata['arch'], self.suffix)
        self.description = "name=%s, arch=%s, ancestor_name=%s, ancestor_id=%s, ancestor_version=%s" % (
                            self.name, self.vol.ami_metadata['arch'],
                            self.vol.ami_metadata['base_ami_name'],
                            self.vol.ami_metadata['base_ami_id'],
                            self.vol.ami_metadata['base_ami_version'])


def main():
    import optparse

    usage = "usage: %prog [options]"
    parser = optparse.OptionParser(usage)
    parser.add_option("-b", action="store", dest="base_ami_name", default=None,
                        help="REQUIRED, the name of base AMI on which to build.\n")
    parser.add_option("-p", action="store", dest="pkg",
                        help="REQUIRED, name of package to install\n")
    parser.add_option("-n", action="store", dest="name", default=None,
                        help="name of resultant AMI (default package_name-version-release-arch-yyyymmddHHMM-ebs)\n")
    parser.add_option("-r", action="store", dest="regions, default=None",
                        help="comma delmitted list of regions to copy resultant AMI (unimplemented)\n")
    parser.add_option("-s", action="store", dest="suffix", default=now().strftime('%Y%m%d%H%M'),
                        help="suffix of ami name, (default yyyymmddHHMM)\n")
    parser.add_option("-e", action="store", dest="executor", default="aminator",
                        help="the name of the user invoking\n")

    (options, args) = parser.parse_args()
    base_ami_name = options.base_ami_name
    pkg = options.pkg
    executor = options.executor
    ami_name = options.name
    ami_suffix = options.suffix
    logging_init()
    log.info("executor  = %s" % (executor))
    log.info("pkg       = %s" % (str(pkg)))
    log.info("ami_name  = %s" % (str(ami_name)))
    log.info("ami_suffix= %s" % (str(ami_suffix)))
    # make log details url a configurable
    log_details_url = "http://%s:7001/AdminLogs/list?re=app-ami-bake.log&grep=%s" % (this_instance.public_dns_name,
                                                                                     urllib.quote('.*\[') + pid +
                                                                                     urllib.quote('\]'))
    log.info("Detailed logs: " + log_details_url)

    if pkg is None or base_ami_name is None:
        parser.print_help()
        return(1)

    ec2 = ec2connection()
    try:
        log.info('looking up base AMI named ' + base_ami_name)
        baseami = ec2.get_all_images(filters={'name': options.base_ami_name})[0]
    except IndexError:
        log.error('could not locate the base AMI named %s' % base_ami_name)
        return(1)

    bakereq = BakeRequest(pkg=pkg, base=baseami, wants_ebs=True, wants_s3=False, name=ami_name,
                          suffix=ami_suffix, creator=executor)
    if bakereq.bake() is not True:
        return(1)
    return(0)


if __name__ == '__main__':
    sys.exit(main())
